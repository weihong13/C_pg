#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//int main() {
//	int a = 7 % 2;
//	int b = 7 / 2;
//	printf("%d\n", a);	
//	printf("%d\n", b);
//	return 0;
//}


// 移位操作符 
// << 左移        >> 右移  对二进制操作，只针对整数，浮点数不能左移右移

// 整数的二进制有3中 
// 原码
// 反码
// 补码

// 7  正整数的原码、反码、补码相同
// 0000 0000 0000 0000 0000 0000 0000 0111 原码
// 0000 0000 0000 0000 0000 0000 0000 0111 反码
// 0000 0000 0000 0000 0000 0000 0000 0111 补码

// -7  负整数的原码、反码、补码
// 1000 0000 0000 0000 0000 0000 0000 0111 原码（符号位取反）
// 1111 1111 1111 1111 1111 1111 1111 1000 反码（除符号位外，全部取反）
// 1111 1111 1111 1111 1111 1111 1111 1001 补码（反码+1）

// 整型在内存中存储的是补码

//// 左移操作符 --左面丢弃，右面补 0 ，
//int main() {
//	//// 正整数左移
//	//int a = 7;  // 7的补码 0000 0000 0000 0000 0000 0000 0000 0111
//	//int b = a << 1; // 左移一位 0000 0000 0000 0000 0000 0000 0000 1110 // 14
//	//int c = a << 2;
//	//int d = a << 3;
//	//printf("a=%d\n", a); // 7
//	//printf("b=%d\n", b); // 14 7*2
//	//printf("c=%d\n", c); // 28 7*4
//	//printf("d=%d\n", d); // 56 7*8
//
//	// 负整数左移
//	int a = -7;  // 存的是-7补码  1111 1111 1111 1111 1111 1111 1111 1001
//	int b = a << 1; // 左移一位   1111 1111 1111 1111 1111 1111 1111 0010  （补码）
//					// 反码：     1111 1111 1111 1111 1111 1111 1111 0001  （补码-1）
//					// 原码：     1000 0000 0000 0000 0000 0000 0000 1110   -14（反码除符号位取反）
//	//打印输出的是原码
//	int c = a << 2;
//	int d = a << 3;
//	printf("a=%d\n", a); // -7
//	printf("b=%d\n", b); // -14 -7*2
//	printf("c=%d\n", c); // -28 -7*4
//	printf("d=%d\n", d); // -56 -7*8
//
//	return 0;
//
//}


// 右移操作符 >>
// 算术移位--右面丢弃，左面补原符号位（正数补0，负数补1）
// 逻辑移位--右面丢弃，左面补0
// vs2019采用的是算术移位，大多都是
//int main() {
//
//	int a = 7;      // 存的是补码 0000 0000 0000 0000 0000 0000 0000 0111
//	int b = a >> 1; // 算术移位   0000 0000 0000 0000 0000 0000 0000 0011 （补码、反码、原码）//3
//	int c = a >> 2;
//	int d = a >> 3;
//	int e = a >> 4;
//	printf("a=%d\n", a);  // 7
//	printf("b=%d\n", b);  // 3
//	printf("c=%d\n", c);  // 1
//	printf("d=%d\n", d);  // 0
//
//
//	//int a = -7;     // 存的是补码 1111 1111 1111 1111 1111 1111 1111 1001
//	//int b = a >> 1; // 算术移位   1111 1111 1111 1111 1111 1111 1111 1100 （补码）
//	//				// 反码      1111 1111 1111 1111 1111 1111 1111 1011  （补码-1）
//	//				// 原码      1000 0000 0000 0000 0000 0000 0000 0100 （除符号位，反码取反）// -4
//	//int c = a >> 2;
//	//int d = a >> 3;
//	//int e = a >> 4;
//	//printf("a=%d\n", a);
//	//printf("b=%d\n", b);
//	//printf("c=%d\n", c);
//	//printf("d=%d\n", d);
//
//
//	return 0;
//}


// 位操作符
// & 按位 与 （有0为0，同一为一）
// | 按位 或  (有一为一，同0为0)
// ^ 按位 异或（相同为0，相异为一）

//int main() {
//	int a = 3;
//	int b = -5;
//	int c = a & b;
//	int d = a | b;
//
//	// 0000 0000 0000 0000 0000 0000 0000 0011  -- 3的补码
//	// 1000 0000 0000 0000 0000 0000 0000 0101  -- -5的原码
//	// 1111 1111 1111 1111 1111 1111 1111 1010  -- -5的反码
//	// 1111 1111 1111 1111 1111 1111 1111 1011  -- -5的补码
//	// 0000 0000 0000 0000 0000 0000 0000 0011  -- 3的补码
//	// 0000 0000 0000 0000 0000 0000 0000 0011  -- 3 & -5  // 3
//	// 1111 1111 1111 1111 1111 1111 1111 1011  -- 3 | -5 (补码)
//	// 1111 1111 1111 1111 1111 1111 1111 1010  -- 3 | -5 (反码)
//	// 1000 0000 0000 0000 0000 0000 0000 0101  -- 3 | -5 (原码) // -5
//	int e = a ^ b;
//	// 0000 0000 0000 0000 0000 0000 0000 0011  -- 3的补码
//	// 1111 1111 1111 1111 1111 1111 1111 1011  -- -5的补码
//	// 1111 1111 1111 1111 1111 1111 1111 1000  -- 3 ^ -5 (补码)
//	// 1111 1111 1111 1111 1111 1111 1111 0111  -- 3 ^ -5 (反码)
//	// 1000 0000 0000 0000 0000 0000 0000 1000  -- 3 ^ -5 (原码) // -8
//
//	printf("c=%d\n", c); // 3
//	printf("d=%d\n", d); // -5
//	printf("e=%d\n", e); // -8
//
//	return 0;
//}

// 不使用临时变量，交换俩个数的值
// 3 ^ 3 = 0
// 011
// 011

// 3 ^ 0 = 3
// 011
// 000 

// 3 ^ 3 ^ 5 =0 ^ 5 = 5
// 3 ^ 5 ^ 3 = 5
// 异或符合交换律
// 011
// 101
// 110
// 011
// 101
//int main() {
//	// 使用临时变量
//	int a = 3;
//	int b = 5;
//	printf("交换前：a=%d, b=%d\n", a, b);
//	a = a ^ b; // 3 ^ 5
//	b = a ^ b; // 3 ^ 5 ^ 5 = 3
//	a = a ^ b; // 3 ^ 5 ^ 3 = 5
//	printf("交换后：a=%d, b=%d\n", a, b);
//	return 0;
//}


//int main() {
//	// 使用临时变量
//	int a = 3;
//	int b = 5;
//	printf("交换前：a=%d, b=%d\n", a, b);
//	a = a+b;  // 可能会溢出
//	b = a-b; // (a+b)-b = a
//	a = a-b; // (a + b) - a
//	printf("交换后：a=%d, b=%d\n", a, b);
//	return 0;
//}


//int main() {
//	// 使用临时变量
//	int a = 3;
//	int b = 5;
//	int temp = 0;
//	printf("交换前：a=%d, b=%d", a, b);
//	temp = a;
//	a = b;
//	b = temp;
//	printf("交换后：a=%d, b=%d", a, b);
//	return 0;
//}

// sizeof() 是单目操作符

//int main() {
//	int a = 10;
//	int n = sizeof(a);
//	printf("%d\n", n);
//	return 0;
//}

// ~ 按位取反

//int main() {
//	int a = 0;
//	// 0000 0000 0000 0000 0000 0000 0000 0000
//	// 1111 1111 1111 1111 1111 1111 1111 1111 ~a 补码
//	// 1111 1111 1111 1111 1111 1111 1111 1110 反码
//	// 1000 0000 0000 0000 0000 0000 0000 0001 // -1
//	printf("%d\n", ~a);
//
//	int b = 3;
//	// 0000 0000 0000 0000 0000 0000 0000 0011
//	// 1111 1111 1111 1111 1111 1111 1111 1100 ~b 补码
//	// 1111 1111 1111 1111 1111 1111 1111 1011 反码
//	// 1000 0000 0000 0000 0000 0000 0000 0100 原码 // -4
//	printf("%d\n", ~b);
//	return 0;
//}


//int main() {
//
//	int a = 13;
//	printf("%d\n", a);
//	//  0000 0000 0000 0000 0000 0000 0000 1101 //想把 1101 变为1111 即指定为变为1
//	//  0000 0000 0000 0000 0000 0000 0000 0010  按位或 1 << 1
//	//  0000 0000 0000 0000 0000 0000 0000 1111  
//	a |= (1 << 4);
//	printf("%d\n", a);
//	// 0000 0000 0000 0000 0000 0000 0001 1101
//
//	// 想把某一位变为0
//	// 0000 0000 0000 0000 0000 0000 0001 1101 第五位变为0
//	// 1111 1111 1111 1111 1111 1111 1110 1111 按位 与
//	// 0000 0000 0000 0000 0000 0000 0001 0000 取反 ~(1<<4)
//	a &= ~(1 << 4);
//	printf("%d\n", a);
//
//
//}

//// ++  --
//int main() {
//	int a = 3;
//	// a= a+1; b = a;
//	// int b = ++a; // a = 4; b = 4;
//	// b = a; a = a +1
//	int b = a++; // b = 3; a = 4;
//
//	return 0;
//}

//int main() {
//	int arr[10] = { 0 };
//
//	// arr[7] ----> *(arr+7) ----> *(7+arr) ----> 7[arr]
//	arr[7] = 8;
//	7[arr] = 9;
//	return 0;
//}

// 结构体调用操作符
// .
// ->

//#include<string.h>
//struct std {
//	char name[20];
//	int age;
//	double score;
//};
//void set_std(struct std* ps) {
//	//strcpy((*ps).name, "weihong");
//	//(*ps).age = 20;
//	//(*ps).score = 99.9;
//	
//	// 结构体指针 -> 成员变量
//	strcpy(ps->name, "weihong");
//	ps->age = 20;
//	ps->score = 99.9;
//}
//
//void print_s(struct std ss) {
//	// 结构体对象.成员变量
//	printf("%s %d %lf\n", ss.name, ss.age, ss.score);
//}
//
//int main() {
//	struct std s = { 0 };
//	set_std(&s);
//	print_s(s);
//}


// 表达式求值

// 隐式类型转换

////整型的提升
//int main() {
//	char ch1 = -1;
//	// 1000 0000 0000 0000 0000 0000 0000 0001 （-1）原码
//	// 1111 1111 1111 1111 1111 1111 1111 1110  (-1) 反码
//	// 1111 1111 1111 1111 1111 1111 1111 1111 （-1）补码
//	// 1111 1111    以char类型存放，只能存放8个比特位，直接截断
//	// 输出的时候，按照int类型大小输出，32位，负数补1，整数补0
//	char ch2 = 1;
//	// 0000 0000 0000 0000 0000 0000 0000 0001 （1）原码、反码、补码
//	// 0000 0001
//
//}

//int main() {
//	char a = 5;
//	// 0000 0000 0000 0000 0000 0000 0000 0101
//	// 0000 0101 char
//	char b = 126;
//	// 0000 0000 0000 0000 0000 0000 0111 1110
//	// 0111 1110 char
//
//	char c = a + b;
//	// 0000 0000 0000 0000 0000 0000 0000 0101 a
//	// 0000 0000 0000 0000 0000 0000 0111 1110 b
//	// 0000 0000 0000 0000 0000 0000 1000 0011 c
//	// 1000 0011  char
//	// 1111 1111 1111 1111 1111 1111 1000 0011 (补码)
//	// 1111 1111 1111 1111 1111 1111 1000 0010 （反码）
//	// 1000 0000 0000 0000 0000 0000 0111 1101 （原码） //-125
//
//	printf("%d\n", c);
//	printf("%c\n", c);
//	return 0;
//}


// 表达式的求解顺序 先看优先级，优先级相同看结合性（从右向左，从左向右），最后看是否空值求值顺序
// 优先级只看相邻表达式

//int main() {
//	int a, b, c, d, e, f;
//
//	   a* b + c * d + e * f;
//	//  1   4   2   5   3
//	//  1   3   2   5   4
//	// 有两种顺序，看似没问题，但如果a~f 是条件表达式，且互相有影响，不同的顺序就会出现不同的结果
//	// 这种表达式就是 问题表达式
//	return 0;
//
//}


//// 小雷上楼要走n个台阶，一次走一个台阶或者一次走两个台阶，一共有几种走法
//int fib(int n) {
//	if (1 == n) {
//		return 1;
//	}
//	if (2 == n) {
//		return 2;
//	}
//	return fib(n - 1) + fib(n - 2);
//}
//int main() {
//	int n = 0;
//	scanf("%d", &n);
//	int ret = fib(n);
//	printf("%d\n", ret);
//	return 0;
//}


// 删除数组序列中指定的元素

int main() {
	int n = 0;
	scanf("%d", &n);
	int arr[50] = { 0 };
	int i = 0;
	int m = 0;
	for (i = 0; i < n; i++) {
		scanf("%d", &m);
		arr[i] = m;
	}
	int del = 0;
	scanf("%d", &del);
	int j = 0;
	for (i = 0; i <= n; i++) {
		if (arr[i] != del) {
			arr[j++] = arr[i];
		}
	}
	for (i = 0; i < j; i++) {
		printf("%d ", arr[i]);
	}
	return 0;
}