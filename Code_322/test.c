#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//// 倒序字符串， Hello Wei Hong! --> Hong! Wei Hello
//
//// 1. Hello Wei Hong!
//// 2. !gnoH ieW olleH 倒序整个字符串
//// 3. Hong! Wei Hello 倒序每个单词
////// 倒序整个字符串
////void Reverse_str(char* str ,int left,int right) {
////	char temp = 0;
////	while (left < right) {
////		temp = str[left];
////		str[left] = str[right];
////		str[right] = temp;
////		left++;
////		right--;
////	}
////}
////// 倒序每个单词
////void Reverse_word(char* str) {
////	int left = 0;
////	int right = 0;
////
////	while (str[left]) {
////		while (str[right] != ' ' && str[right] != '\0') {
////			right++;
////		}
////
////		Reverse_str(str, left,right-1);
////		if (str[right] != '\0') {
////			right++;
////		}
////		
////		left = right;
////	}
////		
////	printf("%s",str);
////
////
////}
////int main() {
////	char arr[20] = { 0 };
////	gets(arr);
////	// 倒序字符串
////	int len = strlen(arr);
////	Reverse_str(arr,0,len-1);
////	// 倒序每个单词
////	Reverse_word(arr);
////	return 0;
////}


//// 数据在内存中的存储
//
//// 整数在内存中的存储：原码、反码、补码
//// 大小端字节序
//// 浮点型在内存中的存储
//	
//// 字符的本质是 整型，在内存中以ASCII码值进行存储
//
//// 构造类型
//// 1. 数组类型  int [5],int [8],char [20]
//// 2. 结构体类型 struct
//// 3. 枚举类型  enum
//// 4. 联合类型  union
//
//// 指针类型  void* q 
//
//// 空类型 void 
////void test(void) { // 第一个void代表 无返回值，第二个void代表该函数无需传参
////	printf("hehe");
////}
////int main() {
////	test(1);
////	return 0;
////}



//// 整型在内存中的存储
//// 整数2进制 有三种表示方式--原码、反码、补码
//// 整数在内存中存补码
//// 补码运算优点 1-1 = 1+（-1）
//// 0000 0000 0000 0000 0000 0000 0000 0001
//// 1111 1111 1111 1111 1111 1111 1111 1111 +
////10000 0000 0000 0000 0000 0000 0000 0000
//// 0000 0000 0000 0000 0000 0000 0000 0000 = 0
//int main() {
//	int a = 20;
//	// 0000 0000 0000 0000 0000 0000 0001 0100 正数 原码、反码、补码相同
//	// 0x 00 00 00 14
//	// 内存中 0x 14 00 00 00 
//	int b = -10;
//	// 1000 0000 0000 0000 0000 0000 0000 1010 原码
//	// 1111 1111 1111 1111 1111 1111 1111 0101 反码
//	// 1111 1111 1111 1111 1111 1111 1111 0110 补码（原码取反+1）
//	// 0x ff ff ff f6
//	// 内存中 0x f6 ff ff ff
//	// 原码取+1得到补码
//	// 补码取反+1 也能得到原码
//	// 1000 0000 0000 0000 0000 0000 0000 1010 原码
//	// 1111 1111 1111 1111 1111 1111 1111 0110 补码（原码取反+1）
//	// 1000 0000 0000 0000 0000 0000 0000 1001 补码取反
//	// 1000 0000 0000 0000 0000 0000 0000 1010 补码取反+1 得到原码
//	return 0;
//}
//


// 大小端介绍-- 取决硬件
//								0x(高位) 11 22 33 44  （低位）
// 大端字节序存储  高位在低地址 低地址---> 0x 11 22 33 44 ---->高地址 
// 小端字节序存储  高位在高地址 低地址---> 0x 44 33 22 11 ---->高地址  反着存

// char 就一个字节，不存在大小端问题

// 判断大端小端

//int main() {
//	int a = 1;
//	// 大端 0x 00 00 00 01
//	// 小端 0X 01 00 00 00
//	// 以char* 类型取 int a，字符类型指针，每次只取一个字节
//	// 如果取到的是 00，说明是大端，如果取到的是 01 说明是小端
//	char* pa = &a;
//	if (*pa) {
//		printf("小端");
//	}
//	else {
//		printf("大端");
//	}
//	return 0;
//}

//// 判断输出
//int main() {
//	// char 一个字节，八位
//	char a = 1;
//	// 00000000 00000000 00000000 00000001
//	// 00000001 a 截断
//	signed char b = -1; // 范围 -128~127 -128 1000000
//	// 10000000 00000000 00000000 00000001
//	// 11111111 11111111 11111111 11111110
//	// 11111111 11111111 11111111 11111111 补码
//	// 11111111 b = 截断
//	// %d 打印是整型 32位，需要整型提升
//	// 11111111 11111111 11111111 11111111 补码
//	// 10000000 00000000 00000000 00000001 原码 打印-1
//	unsigned char c = -1; // 范围 0~255
//	// -1 补码
//	// 11111111111111111111111111111111
//	// 11111111  c 截断
//	//  %d 打印是整型 32位，需要整型提升
//	// 且无符号数 高位直接补 0
//	// 00000000 00000000 00000000 11111111 // 255 打印
//	printf("a=%d b=%d c=%d\n", a, b, c);
//
//	char d = -128;
//	// 1000 0000 0000 0000 0000 0000 1000 0000
//	// 1111 1111 1111 1111 1111 1111 0111 1111
//	// 1111 1111 1111 1111 1111 1111 1000 0000 整数补码
//	// 1000 0000  a -截断
//	// %u 无符号整型 按照 a的类型提升
//	// 1111 1111 1111 1111 1111 1111 1000 0000
//	//
//	printf("%u", d); //4294967168
//	return 0;
//}


// 浮点数的存储
// 浮点数 V = (-1)^S * M * 2^E

// 例如: V = 5.0f 
//         = 101.0    （5的二进制101）
//         = 1.01 * 2^2 (二进制科学计数法)  十进制科学计数法 123.45  = 1.2345 *10^2
//         = (-1)^0 * 1.01 * 2^2
//            S=0;  M=1.01; E=2;

// 例如: V = 9.5f 
//         = 1001.1     小数点后面的1 代表 2^(-1) =0.5
//         = 1.0011 * 2^3 (二进制科学计数法)  
//         = (-1)^0 * 1.0011 * 2^3
//            S=0;  M=1.0011; E=3;

// 例如: V = 9.6f 
//         = 1001.1001...10011000....     
//          小数点后面的1001 代表 2^(-1) =0.5 + 2^(-4)= 0.05625 ,只能取到近似值，

// 对于32位的float 最高位存S, 接着是8位存E，剩下的23位存有效数字M
// 对于64位的double 最高位存S, 接着是11位存E，剩下的52位存有效数字M

// 对于M的存储
// IEEE 754 规定，因为默认M是 1 ≤ M ≤ 2，所以M一定是1.xxxxxx的数，
// 以1.01为例在存储时可以省略小数点前的1，只保存01，来增加精度，
// 因此，对于32位浮点数的23位有效数字可以保存24位有效数字

// 对于E的存储
// IEEE 754 规定，E是一个无符号数
// 因此，对于32位float，8位的E的范围是0~255，对于64位double，11位的E的范围是0~2047，
// 但是，科学计数法是存在负数的，
// 例如 V = 0.5, 二进制表示 0.1 
//        = 1 * 2^(-1)
//        = (-1)^0 * 1 * 2^(-1)
//		   S=0;   M=1;   E=(-1)  
// 但已经规定在存储时按照无符号存储，为了解决E为负数的问题，在存储时，需要对E 加一个中间值
// 32位float，E的中间值是127，对于64位double，E的中间值是1023
// 所以，对于 0.5 ： S=0;   M=1;   E=(-1) （真实值）
// 存储的E = (-1) （真实值）+ 127(中间值) = 126

// 对于E的取出，分为3种情况
// E中有1有0，将E 减去127，然后将M 补1取出
// E全为0，直接用 1-127，然后直接将M取出，不用补1，因为已经是非常接近0了，补不补1，无所谓
// E全为1，直接表示-+ 无穷大
//

//int main() {
//	float f = 5.5;
//	// 101.1
//	// 1.011 * 2^2
//	// (-1)^0 * 1.011 * 2^2
//	// S=0, E=2+127, M=1.011
//	// 0          S
//	// 10000001   E 129
//	// 011        M 前面的1不放，只放小数点的后的011
//	// 0 10000001 011  00000000000000000000
//	// 0100 0000 1011 0000 0000 0000 0000 0000
//	// 0x 40 b0 00 00
//	return 0;
//}

//int main() {
//	int n = 9;
//	// [0000 0000 0000 0000 0000 0000 0000 1001] 整数
//	float* pf = (float*) & n;
//	// 将 9 的整型存储形式当作了浮点型
//	// 0 00000000 00000000000000000001001
//	// S    E        M
//	// E 全为0 直接为 -126; M直接取出来，不补1.
//	// (-1)^0 * 0.00000000000000000001001 * 2^(-126)
//	// 0.000000 浮点数默认输出小数点6位
//	printf("n的值为：%d\n", n); // 9
//	printf("*pf的值为：%f\n", *pf);// 0.000000
//
//	*pf = 9.0; // 按照浮点数存储
//	// 1001.0
//	// 1.001 * 2^3
//	// S=0  E=3  M=1.001,  E存130，M存001
//	// 0 10000010 001 00000000000000000000
//	// [01000001000100000000000000000000]
//	// 按照整型输出是个很大的数字
//	printf("n的值为：%d\n", n); // 1091567616
//	printf("*pf的值为：%f\n", *pf); // 9.000000
//	return 0;
//}

// 输入一个整型数组，
// 实现一个函数
// 将输入的数组的奇数放入前半部分，偶数放到后面
//void Fun(int* arr1, int sz) {
//	int left = 0;
//	int right = sz - 1;
//	int  temp = 0;
//	while (left < right) {
//		// 从左向右找一个偶数
//		while ((left < right) && arr1[left]%2==1) { // 防止全为奇数的时候访问越界
//			left++;
//		}
//		// 从右向左找一个奇数
//		while ((left < right) && arr1[right]%2 == 0) {// 防止全为偶数的时候访问越界
//			right--;
//		}
//		// 交换
//		if (left < right) {
//			temp = arr1[left];
//			arr1[left] = arr1[right];
//			arr1[right] = temp;
//			left++;
//			right--;
//		}
//
//	}
//}
//int main() {
//	int arr[10] = { 0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	// 输入
//	int  i = 0;
//	for (i = 0; i < sz; i++) {
//		scanf("%d", &arr[i]);
//	}
//	// 调整
//	Fun(arr, sz);
//	// 输出
//	for (i = 0; i < sz; i++) {
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}
//


// 两个有序序列合并-将两个有序的序列合并为一个有序的序列
// 输入3行
// 第一行输入n m
// 第二行输入 n个数字的 升序序列
// 第三行输入 m个数字的 升序序列
void merge_arr(int arrn[], int arrm[], int arr_merge[], int n, int m) {
	int i = 0;
	int j = 0;
	int k = 0;

	while (i < n && j < m) {
		// 将小值给到 合并序列
		if ( arrn[i] <= arrm[j]) {  // 防止越界访问
			arr_merge[k] = arrn[i];
			k++;
			i++;
		}
		else if( arrn[i] > arrm[j])// 防止越界访问
		{
			arr_merge[k] = arrm[j];
			k++;
			j++;
		}
	}
	// 将剩下的值给到 合并后的序列
	if (n <= m) { 
		while (j < m) {
			arr_merge[k] = arrm[j];
			k++;
			j++;
		}

	}
	if (n >= m) {
		while (i < n) {
			arr_merge[k] = arrm[i];
			k++;
			i++;
		}

	}
}
int main() {
	//输入
	int n = 0;
	int m = 0;
	scanf("%d %d", &n, &m);
	int arrn[1000] = {0};
	int arrm[1000] = { 0 };
	int i = 0;
	for (i = 0; i < n; i++) {
		scanf("%d", &arrn[i]);
	}
	for (i = 0; i < m; i++) {
		scanf("%d", &arrm[i]);
	}
	// 合并
	int arr_merge[2000] = { 0 };
	merge_arr(arrn, arrm, arr_merge,n, m);
	// 输出
	for (i = 0; i < m+n; i++) {
		printf("%d ", arr_merge[i]);
	}
	return 0;
}